name: Build Main Branch

on:
  push:
    branches:
      - main
    tags-ignore:
      - 'v*.*.*'

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  quality-checks:
    name: Code Quality & Tests
    runs-on: ubuntu-latest
    outputs:
      lint-failed: ${{ steps.lint.outputs.exit_code }}
      test-failed: ${{ steps.test.outputs.exit_code }}
      e2e-failed: ${{ steps.e2e.outputs.exit_code }}

    services:
      mongodb:
        image: mongo:8.0.17
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: test
          MONGO_INITDB_ROOT_PASSWORD: test
          MONGO_INITDB_DATABASE: tech_challenge
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.adminCommand({ping: 1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run linter
        id: lint
        continue-on-error: true
        shell: bash {0}
        run: |
          set +e
          pnpm run lint 2>&1 | tee lint-output.txt
          LINT_EXIT=$?
          echo "exit_code=$LINT_EXIT" >> $GITHUB_OUTPUT
          exit 0

      - name: Run unit tests
        id: test
        continue-on-error: true
        shell: bash {0}
        run: |
          set +e
          pnpm run test 2>&1 | tee test-output.txt
          TEST_EXIT=$?
          echo "exit_code=$TEST_EXIT" >> $GITHUB_OUTPUT
          exit 0

      - name: Run E2E tests
        id: e2e
        continue-on-error: true
        shell: bash {0}
        env:
          MONGODB_URI: mongodb://test:test@localhost:27017/tech_challenge?authSource=admin
        run: |
          set +e
          pnpm run test:e2e 2>&1 | tee e2e-output.txt
          E2E_EXIT=$?
          echo "exit_code=$E2E_EXIT" >> $GITHUB_OUTPUT
          exit 0

      - name: Upload test outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-outputs
          path: |
            lint-output.txt
            test-output.txt
            e2e-output.txt
          retention-days: 7

      - name: Check quality gates
        if: steps.lint.outputs.exit_code != '0' || steps.test.outputs.exit_code != '0' || steps.e2e.outputs.exit_code != '0'
        run: |
          echo "::error::Quality checks failed"
          echo "Lint: ${{ steps.lint.outputs.exit_code }}"
          echo "Tests: ${{ steps.test.outputs.exit_code }}"
          echo "E2E: ${{ steps.e2e.outputs.exit_code }}"
          exit 1

  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: quality-checks
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/image.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  security-scan:
    name: Security Scan (Trivy)
    runs-on: ubuntu-latest
    needs: build-image
    permissions:
      security-events: write
    outputs:
      trivy-failed: ${{ steps.trivy.outputs.exit_code }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/image.tar

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Run Trivy vulnerability scanner
        id: trivy
        continue-on-error: true
        shell: bash {0}
        run: |
          set +e
          trivy image --format sarif --output trivy-results.sarif --severity CRITICAL,HIGH --exit-code 1 ${{ fromJSON(steps.meta.outputs.json).tags[0] }} 2>&1 | tee trivy-output.txt
          TRIVY_EXIT=$?
          echo "exit_code=$TRIVY_EXIT" >> $GITHUB_OUTPUT
          exit 0

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Upload Trivy output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-output
          path: trivy-output.txt
          retention-days: 7

      - name: Check security gate
        if: steps.trivy.outputs.exit_code != '0'
        run: |
          echo "::error::Security vulnerabilities found"
          echo "Trivy exit code: ${{ steps.trivy.outputs.exit_code }}"
          exit 1

  push-image:
    name: Push to Registry
    runs-on: ubuntu-latest
    needs: security-scan
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/image.tar

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Push Docker image
        run: |
          docker tag $(docker images -q | head -1) ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
          docker push ${{ fromJSON(steps.meta.outputs.json).tags[0] }}

      - name: Generate build summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ fromJSON(steps.meta.outputs.json).tags[0] }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Successfully pushed to registry" >> $GITHUB_STEP_SUMMARY

  report-failures:
    name: Report CI/CD Failures
    runs-on: ubuntu-latest
    needs: [quality-checks, build-image, security-scan]
    if: always() && (needs.quality-checks.result == 'failure' || needs.security-scan.result == 'failure')
    permissions:
      issues: write

    steps:
      - name: Download test outputs
        if: needs.quality-checks.result == 'failure'
        uses: actions/download-artifact@v4
        with:
          name: test-outputs
        continue-on-error: true

      - name: Download Trivy output
        if: needs.security-scan.result == 'failure'
        uses: actions/download-artifact@v4
        with:
          name: trivy-output
        continue-on-error: true

      - name: Create or update issue
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read outputs
            let lintOutput = '';
            let testOutput = '';
            let e2eOutput = '';
            let trivyOutput = '';

            try { lintOutput = fs.readFileSync('lint-output.txt', 'utf8'); } catch(e) {}
            try { testOutput = fs.readFileSync('test-output.txt', 'utf8'); } catch(e) {}
            try { e2eOutput = fs.readFileSync('e2e-output.txt', 'utf8'); } catch(e) {}
            try { trivyOutput = fs.readFileSync('trivy-output.txt', 'utf8'); } catch(e) {}

            // Build issue body
            let issueBody = `## CI/CD Pipeline Failures\n\n`;
            issueBody += `**Commit**: ${context.sha.substring(0, 7)}\n`;
            issueBody += `**Branch**: ${context.ref.replace('refs/heads/', '')}\n`;
            issueBody += `**Workflow Run**: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n`;

            const lintFailed = '${{ needs.quality-checks.outputs.lint-failed }}' !== '0' && '${{ needs.quality-checks.outputs.lint-failed }}' !== '';
            const testFailed = '${{ needs.quality-checks.outputs.test-failed }}' !== '0' && '${{ needs.quality-checks.outputs.test-failed }}' !== '';
            const e2eFailed = '${{ needs.quality-checks.outputs.e2e-failed }}' !== '0' && '${{ needs.quality-checks.outputs.e2e-failed }}' !== '';
            const trivyFailed = '${{ needs.security-scan.outputs.trivy-failed }}' !== '0' && '${{ needs.security-scan.outputs.trivy-failed }}' !== '';

            if (lintFailed) {
              issueBody += `### Linter Failed\n\n`;
              issueBody += `Exit code: ${{ needs.quality-checks.outputs.lint-failed }}\n\n`;
              issueBody += `<details><summary>Lint Output</summary>\n\n\`\`\`\n${lintOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (testFailed) {
              issueBody += `### Unit Tests Failed\n\n`;
              issueBody += `Exit code: ${{ needs.quality-checks.outputs.test-failed }}\n\n`;
              issueBody += `<details><summary>Test Output</summary>\n\n\`\`\`\n${testOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (e2eFailed) {
              issueBody += `### E2E Tests Failed\n\n`;
              issueBody += `Exit code: ${{ needs.quality-checks.outputs.e2e-failed }}\n\n`;
              issueBody += `<details><summary>E2E Output</summary>\n\n\`\`\`\n${e2eOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (trivyFailed) {
              issueBody += `### Security Scan Failed (Trivy)\n\n`;
              issueBody += `Exit code: ${{ needs.security-scan.outputs.trivy-failed }}\n\n`;
              issueBody += `Found CRITICAL or HIGH severity vulnerabilities in Docker image.\n\n`;
              issueBody += `<details><summary>Trivy Output</summary>\n\n\`\`\`\n${trivyOutput}\n\`\`\`\n</details>\n\n`;
            }

            issueBody += `---\n\n`;
            issueBody += `## Action Required\n\n`;
            issueBody += `**BLOCKING**: These failures prevent the Docker image from being pushed to the registry.\n\n`;
            issueBody += `**Impact**:\n`;
            issueBody += `- Docker image will NOT be pushed to GitHub Container Registry\n`;
            issueBody += `- Production deployment is BLOCKED until these issues are resolved\n`;
            issueBody += `- No new artifacts will be available for deployment\n\n`;
            issueBody += `**Next Steps**:\n`;
            issueBody += `1. Review the detailed error outputs above\n`;
            issueBody += `2. Fix the failing checks locally\n`;
            issueBody += `3. Run tests locally: \`pnpm run lint && pnpm run test && pnpm run test:e2e\`\n`;
            issueBody += `4. Push your fixes to trigger a new CI run\n`;
            issueBody += `5. This issue will be updated or closed automatically\n\n`;
            issueBody += `*This issue was automatically created by the CI/CD pipeline.*`;

            // Check for existing open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              per_page: 100
            });

            const existingIssue = issues.data.find(issue =>
              issue.title === 'CI/CD Pipeline Failures on main branch'
            );

            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## New Failure Detected\n\n${issueBody}`
              });
              console.log(`Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'CI/CD Pipeline Failures on main branch',
                body: issueBody,
                labels: ['ci-failure', 'bug', 'automated']
              });
              console.log(`Created new issue #${newIssue.data.number}`);
            }
