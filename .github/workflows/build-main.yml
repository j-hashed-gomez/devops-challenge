name: Build Main Branch

on:
  push:
    branches:
      - main
    tags-ignore:
      - 'v*.*.*'
  pull_request:
    branches:
      - main

env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

jobs:
  quality-checks:
    name: Code Quality & Tests
    runs-on: ubuntu-latest

    services:
      mongodb:
        image: mongo:8.0.17
        ports:
          - 27017:27017
        env:
          MONGO_INITDB_ROOT_USERNAME: test
          MONGO_INITDB_ROOT_PASSWORD: test
          MONGO_INITDB_DATABASE: tech_challenge
        options: >-
          --health-cmd "mongosh --quiet --eval 'db.adminCommand({ping: 1})'"
          --health-interval 10s
          --health-timeout 5s
          --health-retries 5

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '20'

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Run all quality checks
        id: quality
        run: |
          # Run all checks and capture results (don't stop on failures)
          LINT_FAILED=0
          TEST_FAILED=0
          E2E_FAILED=0

          echo "Running linter..."
          pnpm run lint 2>&1 | tee lint-output.txt || LINT_FAILED=1

          echo "Running unit tests..."
          pnpm run test 2>&1 | tee test-output.txt || TEST_FAILED=1

          echo "Running E2E tests..."
          pnpm run test:e2e 2>&1 | tee e2e-output.txt || E2E_FAILED=1

          # Fail job if any check failed (blocks PR merge)
          if [ $LINT_FAILED -eq 1 ] || [ $TEST_FAILED -eq 1 ] || [ $E2E_FAILED -eq 1 ]; then
            echo "::error::Quality checks failed - blocking merge"
            exit 1
          fi
        env:
          MONGODB_URI: mongodb://test:test@localhost:27017/tech_challenge?authSource=admin

      - name: Upload test outputs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-outputs
          path: |
            lint-output.txt
            test-output.txt
            e2e-output.txt
          retention-days: 7

  build-image:
    name: Build Docker Image
    runs-on: ubuntu-latest
    needs: quality-checks
    outputs:
      image-tag: ${{ steps.meta.outputs.tags }}

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Build Docker image
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          push: false
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          cache-from: type=gha
          cache-to: type=gha,mode=max
          outputs: type=docker,dest=/tmp/image.tar

      - name: Upload image artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image
          path: /tmp/image.tar
          retention-days: 1

  security-scan:
    name: Security Scan (Trivy)
    runs-on: ubuntu-latest
    needs: build-image
    permissions:
      security-events: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/image.tar

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Install Trivy
        run: |
          wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
          echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
          sudo apt-get update
          sudo apt-get install trivy -y

      - name: Run Trivy vulnerability scanner
        id: trivy
        run: |
          # Run Trivy and capture output
          TRIVY_FAILED=0
          trivy image --severity CRITICAL,HIGH --exit-code 1 ${{ fromJSON(steps.meta.outputs.json).tags[0] }} 2>&1 | tee trivy-output.txt || TRIVY_FAILED=1

          # Also generate SARIF format
          trivy image --format sarif --output trivy-results.sarif --severity CRITICAL,HIGH ${{ fromJSON(steps.meta.outputs.json).tags[0] }} || true

          # Fail job if vulnerabilities found (blocks PR merge)
          if [ $TRIVY_FAILED -eq 1 ]; then
            echo "::error::Security vulnerabilities found - blocking merge"
            exit 1
          fi

      - name: Upload Trivy results to GitHub Security
        uses: github/codeql-action/upload-sarif@v3
        if: always()
        with:
          sarif_file: 'trivy-results.sarif'

      - name: Upload Trivy output
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: trivy-output
          path: trivy-output.txt
          retention-days: 7

  push-image:
    name: Push to Registry
    runs-on: ubuntu-latest
    needs: [security-scan, report-failures]
    if: github.event_name == 'push' && github.ref == 'refs/heads/main' && needs.report-failures.outputs.has-errors != 'true'
    permissions:
      contents: read
      packages: write

    steps:
      - name: Checkout code
        uses: actions/checkout@v4

      - name: Download image artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image
          path: /tmp

      - name: Load Docker image
        run: docker load --input /tmp/image.tar

      - name: Log in to GitHub Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      - name: Extract metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=sha,prefix=main-,format=short

      - name: Push Docker image
        run: |
          docker tag $(docker images -q | head -1) ${{ fromJSON(steps.meta.outputs.json).tags[0] }}
          docker push ${{ fromJSON(steps.meta.outputs.json).tags[0] }}

      - name: Generate build summary
        run: |
          echo "## Build Summary" >> $GITHUB_STEP_SUMMARY
          echo "- **Image**: \`${{ fromJSON(steps.meta.outputs.json).tags[0] }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Commit**: \`${{ github.sha }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Branch**: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
          echo "- **Status**: Successfully pushed to registry" >> $GITHUB_STEP_SUMMARY

  report-failures:
    name: Report CI/CD Failures
    runs-on: ubuntu-latest
    needs: [quality-checks, build-image, security-scan]
    if: always()
    outputs:
      has-errors: ${{ steps.check-errors.outputs.has-errors }}
    permissions:
      issues: write

    steps:
      - name: Download test outputs
        uses: actions/download-artifact@v4
        with:
          name: test-outputs
        continue-on-error: true

      - name: Download Trivy output
        uses: actions/download-artifact@v4
        with:
          name: trivy-output
        continue-on-error: true

      - name: Check for errors
        id: check-errors
        run: |
          # Read outputs
          LINT_OUTPUT=$(cat lint-output.txt 2>/dev/null || echo "")
          TEST_OUTPUT=$(cat test-output.txt 2>/dev/null || echo "")
          E2E_OUTPUT=$(cat e2e-output.txt 2>/dev/null || echo "")
          TRIVY_OUTPUT=$(cat trivy-output.txt 2>/dev/null || echo "")

          # Detect if there are actual errors
          HAS_ERRORS="false"
          if echo "$LINT_OUTPUT" | grep -qE "(error|✖)"; then HAS_ERRORS="true"; fi
          if echo "$TEST_OUTPUT" | grep -qE "(FAIL|failed)"; then HAS_ERRORS="true"; fi
          if echo "$E2E_OUTPUT" | grep -qE "(FAIL|failed)"; then HAS_ERRORS="true"; fi
          if echo "$TRIVY_OUTPUT" | grep -qE "(CRITICAL|HIGH)"; then HAS_ERRORS="true"; fi

          echo "has-errors=$HAS_ERRORS" >> $GITHUB_OUTPUT
          echo "Has errors: $HAS_ERRORS"

      - name: Create or update issue
        if: github.event_name == 'push' && github.ref == 'refs/heads/main' && steps.check-errors.outputs.has-errors == 'true'
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');

            // Read outputs
            let lintOutput = '';
            let testOutput = '';
            let e2eOutput = '';
            let trivyOutput = '';

            try { lintOutput = fs.readFileSync('lint-output.txt', 'utf8'); } catch(e) {}
            try { testOutput = fs.readFileSync('test-output.txt', 'utf8'); } catch(e) {}
            try { e2eOutput = fs.readFileSync('e2e-output.txt', 'utf8'); } catch(e) {}
            try { trivyOutput = fs.readFileSync('trivy-output.txt', 'utf8'); } catch(e) {}

            // Detect which specific checks failed
            const hasLintErrors = lintOutput.includes('error') || lintOutput.includes('✖');
            const hasTestErrors = testOutput.includes('FAIL') || testOutput.includes('failed');
            const hasE2EErrors = e2eOutput.includes('FAIL') || e2eOutput.includes('failed');
            const hasTrivyErrors = trivyOutput.includes('CRITICAL') || trivyOutput.includes('HIGH');

            // Build issue body
            let issueBody = `## CI/CD Pipeline Failures\n\n`;
            issueBody += `**Commit**: ${context.sha.substring(0, 7)}\n`;
            issueBody += `**Branch**: ${context.ref.replace('refs/heads/', '')}\n`;
            issueBody += `**Workflow Run**: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}\n\n`;

            // Show failures with details
            if (hasLintErrors) {
              issueBody += `### Linter Failed\n\n`;
              issueBody += `<details><summary>Lint Output</summary>\n\n\`\`\`\n${lintOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (hasTestErrors) {
              issueBody += `### Unit Tests Failed\n\n`;
              issueBody += `<details><summary>Test Output</summary>\n\n\`\`\`\n${testOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (hasE2EErrors) {
              issueBody += `### E2E Tests Failed\n\n`;
              issueBody += `<details><summary>E2E Output</summary>\n\n\`\`\`\n${e2eOutput}\n\`\`\`\n</details>\n\n`;
            }

            if (hasTrivyErrors) {
              issueBody += `### Security Scan Failed (Trivy)\n\n`;
              issueBody += `Found CRITICAL or HIGH severity vulnerabilities in Docker image.\n\n`;
              issueBody += `<details><summary>Trivy Output</summary>\n\n\`\`\`\n${trivyOutput}\n\`\`\`\n</details>\n\n`;
            }

            issueBody += `---\n\n`;
            issueBody += `## Action Required\n\n`;
            issueBody += `**BLOCKING**: These failures prevent the Docker image from being pushed to the registry.\n\n`;
            issueBody += `**Impact**:\n`;
            issueBody += `- Docker image will NOT be pushed to GitHub Container Registry\n`;
            issueBody += `- Production deployment is BLOCKED until these issues are resolved\n`;
            issueBody += `- No new artifacts will be available for deployment\n\n`;
            issueBody += `**Next Steps**:\n`;
            issueBody += `1. Review the detailed error outputs above\n`;
            issueBody += `2. Fix the failing checks locally\n`;
            issueBody += `3. Run tests locally: \`pnpm run lint && pnpm run test && pnpm run test:e2e\`\n`;
            issueBody += `4. Push your fixes to trigger a new CI run\n`;
            issueBody += `5. This issue will be updated or closed automatically\n\n`;
            issueBody += `*This issue was automatically created by the CI/CD pipeline.*`;

            // Check for existing open issue
            const issues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              state: 'open',
              labels: 'ci-failure',
              per_page: 100
            });

            const existingIssue = issues.data.find(issue =>
              issue.title === 'CI/CD Pipeline Failures on main branch'
            );

            if (existingIssue) {
              // Update existing issue
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: existingIssue.number,
                body: `## New Failure Detected\n\n${issueBody}`
              });
              console.log(`Updated existing issue #${existingIssue.number}`);
            } else {
              // Create new issue
              const newIssue = await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: 'CI/CD Pipeline Failures on main branch',
                body: issueBody,
                labels: ['ci-failure', 'bug', 'automated']
              });
              console.log(`Created new issue #${newIssue.data.number}`);
            }
